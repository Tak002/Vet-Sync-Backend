<!doctype html>
<html lang="ko">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>환자 상태관리표</title>
    <style>
        :root{
            --bg:#0b1220;
            --panel:#0f1b33;
            --panel2:#0c172c;
            --text:#e8eefc;
            --muted:#a9b6d6;
            --line:#223258;

            --empty:#0e1a30;
            --pending:#3a2a00;
            --inprogress:#0b2c3a;
            --confirm:#2a0b3a;
            --completed:#0a3a17;

            --shadow: 0 10px 25px rgba(0,0,0,.35);
            --radius: 14px;

            /* ✅ 축소해서 한눈에 보이도록 폭 줄임 */
            --col1: 150px;   /* Definition */
            --col2: 170px;   /* 공용노트(줄임) */
            --colMemo: 250px;/* 일일 메모(줄임) */

            --col2-left: var(--col1);
        }

        *{box-sizing:border-box}
        body{
            margin:0;
            font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", Arial, "Apple SD Gothic Neo", sans-serif;
            color:var(--text);
            background: radial-gradient(1200px 800px at 30% 10%, #13244a 0%, rgba(19,36,74,0) 60%),
            radial-gradient(1200px 800px at 90% 40%, #1a2a54 0%, rgba(26,42,84,0) 60%),
            var(--bg);
        }

        .app{max-width:1800px;margin:0 auto;padding:18px;display:flex;flex-direction:column;gap:14px}
        .topbar{display:flex;justify-content:space-between;align-items:flex-start;gap:14px}
        .card{
            background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
            border: 1px solid rgba(255,255,255,.08);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
        }

        .patient{flex:1;padding:14px 14px 10px;display:flex;flex-direction:column;gap:10px}
        .patient h1{margin:0;font-size:18px;letter-spacing:.2px}
        .meta{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:10px}
        .kv{
            background: rgba(0,0,0,.15);
            border:1px solid rgba(255,255,255,.08);
            border-radius: 12px;
            padding:10px;
            min-height:54px;
        }
        .kv .k{font-size:12px;color:var(--muted);margin-bottom:4px}
        .kv .v{font-size:13px;word-break:break-all}

        .actions{width:320px;padding:14px;display:flex;flex-direction:column;gap:10px}
        .actions h2{margin:0;font-size:14px;color:var(--muted);font-weight:600}
        .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}

        input[type="text"], input[type="date"], input[type="password"]{
            width:100%;
            background: rgba(0,0,0,.22);
            border:1px solid rgba(255,255,255,.10);
            color: var(--text);
            padding:10px 11px;
            border-radius: 10px;
            outline:none;
        }
        input[type="text"]:focus, input[type="date"]:focus, input[type="password"]:focus{
            border-color: rgba(160,200,255,.45);
            box-shadow: 0 0 0 3px rgba(80,140,255,.18);
        }

        button{
            cursor:pointer;
            background: rgba(90,150,255,.18);
            border:1px solid rgba(90,150,255,.35);
            color: var(--text);
            padding:10px 11px;
            border-radius: 10px;
            font-weight:600;
            transition:.15s ease;
        }
        button:hover{ transform: translateY(-1px); background: rgba(90,150,255,.25); }
        button:active{ transform: translateY(0px); }
        button:disabled{ opacity:.5; cursor:not-allowed; transform:none; }
        .btn-ghost{ background: rgba(255,255,255,.06); border-color: rgba(255,255,255,.10); }
        .btn-success{ background: rgba(70,220,140,.14); border-color: rgba(70,220,140,.30); }

        .legend{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
        .pill{
            display:inline-flex;align-items:center;gap:8px;padding:6px 10px;
            background: rgba(255,255,255,.06);
            border:1px solid rgba(255,255,255,.08);
            border-radius: 999px;font-size:12px;color: var(--muted);
        }
        .dot{width:10px;height:10px;border-radius:50%;background: var(--empty);border:1px solid rgba(255,255,255,.10)}
        .dot.pending{ background: var(--pending); }
        .dot.inprogress{ background: var(--inprogress); }
        .dot.confirm{ background: var(--confirm); }
        .dot.completed{ background: var(--completed); }

        /* ✅ 화면 확대비율을 줄여서 한눈에 보이도록(전체 스케일 다운) */
        .table-zoom{
            transform: scale(.88);
            transform-origin: top left;
            width: calc(100% / .88);
        }

        .table-wrap{padding:12px;overflow:auto;border-radius: var(--radius)}
        table{border-collapse:separate;border-spacing:0;min-width:1600px;width:100%;color:var(--text);font-size:12px}

        thead th{
            position: sticky; top:0; z-index:6;
            background: rgba(12,23,44,.95);
            backdrop-filter: blur(6px);
            border-bottom: 1px solid rgba(255,255,255,.10);
        }
        th, td{
            border-right:1px solid rgba(255,255,255,.06);
            border-bottom:1px solid rgba(255,255,255,.06);
            padding:6px 6px;
            text-align:center;vertical-align:middle;white-space:nowrap
        }

        /* Sticky columns: 1) Definition 2) 공용노트 */
        th:first-child, td:first-child{
            position: sticky; left:0; z-index:5;
            background: rgba(12,23,44,.95);
            backdrop-filter: blur(6px);
            text-align:left;
            min-width:var(--col1); max-width:var(--col1);
        }
        th:nth-child(2), td:nth-child(2){
            position: sticky; left:var(--col2-left); z-index:5;
            background: rgba(12,23,44,.95);
            backdrop-filter: blur(6px);
            text-align:left;
            min-width:var(--col2); max-width:var(--col2);
        }

        td.cell{
            cursor:pointer;
            background: rgba(0,0,0,.12);
            transition:.12s ease;
            min-width:48px; max-width:72px;
            overflow:hidden; text-overflow:ellipsis;
        }
        td.cell:hover{
            outline:2px solid rgba(140,190,255,.45);
            outline-offset:-2px;
            filter: brightness(1.07);
        }
        td.cell.empty{ background: rgba(0,0,0,.10); color: rgba(232,238,252,.35); }
        td.cell.pending{ background: color-mix(in oklab, var(--pending) 82%, black 18%); }
        td.cell.inprogress{ background: color-mix(in oklab, var(--inprogress) 82%, black 18%); }
        td.cell.confirm{ background: color-mix(in oklab, var(--confirm) 82%, black 18%); }
        td.cell.completed{ background: color-mix(in oklab, var(--completed) 82%, black 18%); }

        td.cell .result{
            display:block;font-size:11px;line-height:1.2;max-height:2.4em;
            overflow:hidden;text-overflow:ellipsis;padding:0 2px
        }
        td.cell .sub{display:block;margin-top:3px;font-size:10px;color: rgba(232,238,252,.70);}

        .row-title{display:flex;flex-direction:column;gap:2px;padding:0 2px}
        .row-title .name{font-weight:700}
        .row-title .desc{font-size:11px;color:var(--muted);overflow:hidden;text-overflow:ellipsis}

        td.note-cell{
            cursor:pointer;
            background: rgba(0,0,0,.10);
            transition:.12s ease;
            overflow:hidden;
            text-overflow:ellipsis;
            white-space:nowrap;
        }
        td.note-cell:hover{
            outline:2px solid rgba(140,190,255,.45);
            outline-offset:-2px;
            filter: brightness(1.07);
        }
        td.note-cell .note-text{
            display:block;
            max-width: calc(var(--col2) - 16px);
            overflow:hidden;
            text-overflow:ellipsis;
            white-space:nowrap;
            font-size:11px;
            color: rgba(232,238,252,.92);
        }
        td.note-cell .note-sub{
            display:block;
            margin-top:3px;
            font-size:10px;
            color: rgba(232,238,252,.65);
        }

        /* ✅ 일일 메모 */
        td.ctx-cell{
            background: rgba(0,0,0,.10);
            padding:6px;
            min-width: var(--colMemo);
            max-width: var(--colMemo);
            text-align:left;
            white-space:normal;
        }
        td.ctx-cell input{
            width:100%;
            background: rgba(0,0,0,.18);
            border:1px solid rgba(255,255,255,.10);
            color: var(--text);
            padding:8px 10px;
            border-radius: 10px;
            outline:none;
            font-size:12px;
        }
        td.ctx-cell input:focus{
            border-color: rgba(160,200,255,.45);
            box-shadow: 0 0 0 3px rgba(80,140,255,.18);
        }

        /* ✅ 헤더 아래(제목~첫줄 사이) updatedAt 표시용 */
        .ctx-updated{
            display:block;
            margin-top:6px;
            font-size:10px;
            color: rgba(232,238,252,.65);
            font-weight:500;
        }

        .toast{
            position: fixed; left:50%; bottom:18px; transform: translateX(-50%);
            background: rgba(0,0,0,.55);
            border:1px solid rgba(255,255,255,.10);
            padding:10px 12px;
            border-radius: 12px;
            box-shadow: var(--shadow);
            color: var(--text);
            font-size:13px;
            display:none;
            z-index:9999;
            max-width:90vw;
            white-space:nowrap;
            overflow:hidden;
            text-overflow:ellipsis;
        }

        /* Modal */
        .overlay{position:fixed;inset:0;background: rgba(0,0,0,.55);display:none;z-index:10000;padding:18px}
        .modal{
            max-width: 980px;
            margin:0 auto;
            margin-top:40px;
            background: rgba(15,27,51,.95);
            border:1px solid rgba(255,255,255,.10);
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            overflow:hidden;
        }
        .modal header{
            display:flex;justify-content:space-between;align-items:center;
            padding:12px 14px;border-bottom:1px solid rgba(255,255,255,.08);gap:10px
        }
        .modal header h3{margin:0;font-size:14px;color:var(--text)}
        .modal header .close{background: rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);padding:8px 10px;border-radius: 10px}
        .modal .body{padding:14px;display:flex;gap:12px;flex-direction:column}
        .grid2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
        .two-col{display:grid;grid-template-columns:1fr 1fr;gap:10px}
        .help{font-size:12px;color:var(--muted);line-height:1.45}
        textarea, select{
            width:100%;
            background: rgba(0,0,0,.22);
            border:1px solid rgba(255,255,255,.10);
            color: var(--text);
            padding:10px 11px;
            border-radius: 10px;
            outline:none;
            resize: vertical;
            min-height: 110px;
        }
        select{ min-height: unset; height: 40px; }
        textarea{ min-height: 90px; }
        .modal footer{
            padding:12px 14px;border-top:1px solid rgba(255,255,255,.08);
            display:flex;gap:10px;justify-content:flex-end;flex-wrap:wrap;align-items:center
        }
        .muted{color: var(--muted);font-size:12px}

        @media (max-width: 980px){
            .topbar{flex-direction:column;}
            .actions{width:100%;}
            .meta{grid-template-columns: repeat(2, minmax(0,1fr));}
            .two-col{ grid-template-columns: 1fr; }

            :root{
                --col1: 150px;
                --col2: 160px;
                --colMemo: 230px;
            }

            .table-zoom{
                transform: scale(.82);
                width: calc(100% / .82);
            }
        }
    </style>
</head>

<body>
<div class="app">
    <div class="topbar">
        <div class="card patient">
            <h1 id="patientTitle">환자 정보</h1>
            <div class="meta" id="patientMeta"></div>
        </div>

        <div class="card actions">
            <h2>페이지 설정</h2>

            <div class="row">
                <div style="flex:1">
                    <div class="muted" style="margin:0 0 6px">JWT Token</div>
                    <input id="jwtInput" type="password" placeholder="토큰만 붙여넣기 (Bearer 자동)" />
                </div>
            </div>

            <div class="row">
                <div style="flex:1">
                    <div class="muted" style="margin:0 0 6px">환자 ID</div>
                    <input id="patientIdInput" type="text" placeholder="e2da4625-7158-496f-9f84-9d26b7086ef2" />
                </div>
            </div>

            <div class="row">
                <div style="flex:1">
                    <div class="muted" style="margin:0 0 6px">날짜</div>
                    <input id="dateInput" type="date" />
                </div>
            </div>

            <div class="row">
                <button id="btnLoad">불러오기</button>
                <button id="btnReload" class="btn-ghost">새로고침</button>
            </div>

            <div class="muted">
                경로: <code>/tasks/patients/{patientId}/{taskDate}</code>
            </div>

            <div class="legend">
                <span class="pill"><span class="dot"></span>없음</span>
                <span class="pill"><span class="dot pending"></span>PENDING</span>
                <span class="pill"><span class="dot inprogress"></span>IN_PROGRESS</span>
                <span class="pill"><span class="dot confirm"></span>CONFIRM_WAITING</span>
                <span class="pill"><span class="dot completed"></span>COMPLETED</span>
            </div>

            <div class="help">
                • Task 셀 클릭 → Task 생성/상세<br/>
                • 공용 노트 셀 클릭 → 공용 노트 생성/수정<br/>
                • 우측 메모: 라인별 입력 후 <b>Enter</b> 또는 <b>포커스 아웃</b> 시 자동 저장(PUT)<br/>
                • PATCH 규칙: <b>null=변경없음</b>, <b>""=값 비우기(미지정/삭제)</b><br/>
            </div>
        </div>
    </div>

    <div class="card table-wrap">
        <div class="table-zoom">
            <table id="chartTable" aria-label="환자 상태관리표"></table>
        </div>
    </div>
</div>

<div class="toast" id="toast"></div>

<!-- Modal -->
<div class="overlay" id="overlay">
    <div class="modal">
        <header>
            <h3 id="modalTitle">상세</h3>
            <button class="close" id="modalClose">닫기</button>
        </header>
        <div class="body" id="modalBody"></div>
        <footer id="modalFooter"></footer>
    </div>
</div>

<script>
    /***********************
     * CONFIG
     ***********************/
    const API_BASE = "";

    // ✅ 0~23: AM0..AM11, PM12..PM23
    const HOURS = Array.from({length: 24}, (_, i) => i);
    const hourLabel = (h) => (h < 12 ? `AM${h}` : `PM${h-12}`);
    const STATUS_LIST = ["PENDING","IN_PROGRESS","CONFIRM_WAITING","COMPLETED"];

    /***********************
     * STATE
     ***********************/
    const state = {
        jwtToken: "",
        patientId: null,
        date: null,
        patient: null,

        defs: [],
        defById: new Map(),
        fixedDefs: [],
        notFixedDefs: [],

        staffs: [],
        staffById: new Map(),

        rows: [],
        taskMap: new Map(),
        tasks: [],

        definitionNotes: [],
        noteByDefId: new Map(),

        dayContextNote: null,   // {id, content, updatedAt}
        ctxContent: new Map(),  // key: lineNo(number) -> text
    };

    /***********************
     * HELPERS
     ***********************/
    const $ = (sel) => document.querySelector(sel);
    const escapeHtml = (s) => (s ?? "").toString()
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;").replaceAll('"',"&quot;");

    function toast(msg){
        const t = $("#toast");
        t.textContent = msg;
        t.style.display = "block";
        clearTimeout(toast._timer);
        toast._timer = setTimeout(()=> t.style.display="none", 2200);
    }

    function getPathParamsFromUrl(){
        const parts = location.pathname.split("/").filter(Boolean);
        const idx = parts.indexOf("patients");
        if(idx !== -1 && parts[idx+2] === "management-charts"){
            return { pid: parts[idx+1], date: parts[idx+3] };
        }
        return { pid: null, date: null };
    }

    function statusToClass(status){
        if(!status) return "empty";
        switch(status){
            case "PENDING": return "pending";
            case "IN_PROGRESS": return "inprogress";
            case "CONFIRM_WAITING": return "confirm";
            case "COMPLETED": return "completed";
            default: return "empty";
        }
    }

    function readJwtFromInputAndPersist(){
        const jwt = ($("#jwtInput").value ?? "").trim();
        state.jwtToken = jwt;
        localStorage.setItem("jwtToken", jwt);
    }

    async function apiFetch(path, opts={}){
        const headers = opts.headers ? {...opts.headers} : {};
        headers["Content-Type"] = headers["Content-Type"] ?? "application/json";

        const token = (state.jwtToken ?? "").trim();
        if(token){
            headers["Authorization"] = token.startsWith("Bearer ") ? token : `Bearer ${token}`;
        }

        const res = await fetch(API_BASE + path, {...opts, headers});
        if(!res.ok){
            let body = "";
            try { body = await res.text(); } catch {}
            if(res.status === 401){
                throw new Error(`HTTP 401 Unauthorized - JWT 토큰을 확인해줘. ${body}`.trim());
            }
            throw new Error(`HTTP ${res.status} ${res.statusText} - ${body}`);
        }
        const text = await res.text();
        return text ? JSON.parse(text) : null;
    }

    /***********************
     * ✅ Day Context Notes helpers
     ***********************/
    function buildCtxContentMapFromResponse(resp){
        const m = new Map();
        const obj = resp?.content ?? {};
        for(const [k,v] of Object.entries(obj)){
            const lineNo = Number(k);
            if(Number.isFinite(lineNo)){
                m.set(lineNo, (v ?? "").toString());
            }
        }
        return m;
    }

    function getLineNoByRowIndex(rowIdx){
        return rowIdx + 1; // 1-based
    }

    function updateCtxUpdatedAtHeader(){
        const el = document.querySelector("[data-ctx-updated-at='1']");
        if(!el) return;
        el.textContent = state.dayContextNote?.updatedAt
            ? `updatedAt: ${state.dayContextNote.updatedAt}`
            : "updatedAt: -";
    }

    let ctxSaveTimer = null;
    let ctxSaveInFlight = false;

    function scheduleSaveDayContextNotes(immediate=false){
        clearTimeout(ctxSaveTimer);
        ctxSaveTimer = setTimeout(async ()=>{
            if(ctxSaveInFlight) return;
            if(!state.patientId || !state.date) return;

            try{
                ctxSaveInFlight = true;

                const payloadContent = {};
                const keys = Array.from(state.ctxContent.keys()).sort((a,b)=>a-b);
                for(const k of keys){
                    payloadContent[k] = (state.ctxContent.get(k) ?? "").toString();
                }

                const updated = await API.upsertDayContextNotes(state.patientId, state.date, { content: payloadContent });
                state.dayContextNote = updated;
                state.ctxContent = buildCtxContentMapFromResponse(updated);

                updateCtxUpdatedAtHeader();
                toast("일일 메모 저장 완료");
            }catch(e){
                toast(e.message);
            }finally{
                ctxSaveInFlight = false;
            }
        }, immediate ? 0 : 450);
    }

    /***********************
     * API
     ***********************/
    const API = {
        getPatient: (patientId) => apiFetch(`/patients/${patientId}`, { method:"GET" }),
        getTaskDefinitions: () => apiFetch(`/task-definitions`, { method:"GET" }),
        getPatientDayTasks: (patientId, taskDate) => apiFetch(`/tasks/patients/${patientId}/${taskDate}`, { method:"GET" }),
        createTask: (payload) => apiFetch(`/tasks`, { method:"POST", body: JSON.stringify(payload) }),

        getStaffs: () => apiFetch(`/staffs`, { method:"GET" }),

        patchTask: (taskId, payload) => apiFetch(`/tasks/${taskId}`, { method:"PATCH", body: JSON.stringify(payload) }),
        patchTaskStatus: (taskId, status) => apiFetch(`/tasks/${taskId}/status`, { method:"PATCH", body: JSON.stringify({ status }) }),

        getDefinitionNotes: (patientId, taskDate) => apiFetch(`/tasks/patients/${patientId}/${taskDate}/definition-notes`, { method:"GET" }),
        createDefinitionNote: (patientId, taskDate, payload) => apiFetch(`/tasks/patients/${patientId}/${taskDate}/definition-notes`, { method:"POST", body: JSON.stringify(payload) }),
        patchDefinitionNote: (patientId, taskDate, noteId, payload) => apiFetch(`/tasks/patients/${patientId}/${taskDate}/definition-notes/${noteId}`, { method:"PATCH", body: JSON.stringify(payload) }),

        getDayContextNotes: (patientId, date) => apiFetch(`/patients/${patientId}/day-context-notes/${date}`, { method:"GET" }),
        upsertDayContextNotes: (patientId, date, payload) => apiFetch(`/patients/${patientId}/day-context-notes/${date}`, { method:"PUT", body: JSON.stringify(payload) }),
    };

    /***********************
     * RENDER: PATIENT CARD (그대로)
     ***********************/
    function renderPatient(){
        const p = state.patient;
        if(!p){
            $("#patientTitle").textContent = "환자 정보";
            $("#patientMeta").innerHTML = "";
            return;
        }
        $("#patientTitle").textContent = `환자: ${p.name} (${p.species}${p.speciesDetail ? ` / ${p.speciesDetail}` : ""})`;
        const items = [
            ["환자 ID", p.id],
            ["병원 ID", p.hospitalId],
            ["보호자 ID", p.ownerId],
            ["상태", p.status],
            ["성별", p.gender],
            ["품종", p.breed ?? "-"],
            ["생성자", p.createdBy],
            ["조회 날짜", state.date],
        ];
        $("#patientMeta").innerHTML = items.map(([k,v]) => `
      <div class="kv">
        <div class="k">${escapeHtml(k)}</div>
        <div class="v">${escapeHtml(v ?? "-")}</div>
      </div>
    `).join("");
    }

    /***********************
     * BUILD ROWS / MAPS
     ***********************/
    function buildRows(){
        const fixedRows = state.fixedDefs
            .slice()
            .sort((a,b)=> (a.name ?? "").localeCompare(b.name ?? ""))
            .map(def => ({ type:"DEF", defId:def.id, label:def.name, desc:def.description ?? "" }));

        const usedNotFixedDefIds = new Set();
        for(const t of state.tasks){
            const def = state.defById.get(t.taskDefinitionId);
            if(def && !def.fixed) usedNotFixedDefIds.add(def.id);
        }

        const notFixedRows = Array.from(usedNotFixedDefIds)
            .map(id => state.defById.get(id))
            .filter(Boolean)
            .sort((a,b)=> (a.name ?? "").localeCompare(b.name ?? ""))
            .map(def => ({ type:"DEF", defId:def.id, label:def.name, desc:def.description ?? "" }));

        const blankRows = Array.from({length:4}, (_,i)=>({ type:"BLANK", blankIndex:i+1, label:"(공백)", desc:"클릭해서 항목 추가" }));

        state.rows = [...fixedRows, ...notFixedRows, ...blankRows];
    }

    function buildTaskMap(){
        state.taskMap.clear();
        for(const t of state.tasks){
            state.taskMap.set(`${t.taskDefinitionId}|${t.taskHour}`, t);
        }
    }

    function buildNoteMap(){
        state.noteByDefId = new Map();
        for(const n of (state.definitionNotes ?? [])){
            state.noteByDefId.set(n.taskDefinitionId, n);
        }
    }

    /***********************
     * RENDER TABLE
     * ✅ 1) 처치시간 열 제거
     * ✅ 2) 시간 헤더: AM0..AM11 / PM0..PM11
     * ✅ 3) updatedAt: 일일메모 헤더 아래 1회만 표시
     ***********************/
    function renderTable(){
        const table = $("#chartTable");
        if(!state.date){ table.innerHTML = ""; return; }

        const thead = `
      <thead>
        <tr>
          <th>Date</th>
          <th>공용노트</th>
          <th colspan="12">AM</th>
          <th colspan="12">PM</th>
          <th>Info</th>
          <th>
            <div>일일 메모</div>
            <span class="ctx-updated" data-ctx-updated-at="1"></span>
          </th>
        </tr>
        <tr>
          <th></th>
          <th></th>
          ${Array.from({length:12},(_,i)=>`<th>${escapeHtml(`AM${i}`)}</th>`).join("")}
          ${Array.from({length:12},(_,i)=>`<th>${escapeHtml(`PM${i}`)}</th>`).join("")}
          <th></th>
          <th></th>
        </tr>
      </thead>
    `;

        const rowsHtml = state.rows.map((r, rowIdx)=>{
            const left = r.type==="DEF"
                ? (() => {
                    const def = state.defById.get(r.defId);
                    const name = def?.name ?? r.label;
                    const desc = def?.description ?? r.desc ?? "";
                    return `
            <td>
              <div class="row-title">
                <div class="name">${escapeHtml(name)}</div>
                <div class="desc" title="${escapeHtml(desc)}">${escapeHtml(desc)}</div>
              </div>
            </td>
          `;
                })()
                : `
          <td>
            <div class="row-title">
              <div class="name">(공백)</div>
              <div class="desc">${escapeHtml(r.desc)}</div>
            </div>
          </td>
        `;

            const noteCell = (() => {
                if(r.type !== "DEF"){
                    return `<td class="note-cell muted" title="공백 행은 공용노트를 가질 수 없습니다.">-</td>`;
                }
                const note = state.noteByDefId.get(r.defId) ?? null;
                const noteText = note?.content ?? "";
                const noteId = note?.id ?? "";
                const sub = note ? `id: ${noteId}` : "클릭해서 작성";
                return `
          <td class="note-cell"
              data-cell-kind="NOTE"
              data-def-id="${escapeHtml(r.defId)}"
              data-note-id="${escapeHtml(noteId)}">
            <span class="note-text" title="${escapeHtml(noteText)}">${escapeHtml(noteText || "—")}</span>
            <span class="note-sub">${escapeHtml(sub)}</span>
          </td>
        `;
            })();

            // ✅ hour cells (0..23 그대로, 헤더만 AM0..PM11로 보임)
            const hourCells = HOURS.map(h=>{
                let task = null;
                if(r.type==="DEF") task = state.taskMap.get(`${r.defId}|${h}`) ?? null;

                const cls = task ? statusToClass(task.status) : "empty";
                const labelTop = task?.result ? escapeHtml(task.result) : "—";
                const small = task
                    ? `<span class="sub">${escapeHtml(task.status)}</span>`
                    : `<span class="sub">${escapeHtml(hourLabel(h))}</span>`;

                return `
          <td class="cell ${cls}"
              data-cell-kind="TASK"
              data-row-type="${r.type}"
              data-def-id="${r.type==="DEF" ? r.defId : ""}"
              data-blank-index="${r.type==="BLANK" ? r.blankIndex : ""}"
              data-hour="${h}">
            <span class="result">${labelTop}</span>
            ${small}
          </td>
        `;
            }).join("");

            const rightInfo = (() => {
                if(r.type==="DEF"){
                    const def = state.defById.get(r.defId);
                    const fx = def?.fixed ? "FIXED" : "OPTIONAL";
                    return `<td title="${escapeHtml(def?.description ?? "")}">${escapeHtml(fx)}</td>`;
                }
                return `<td class="muted">빈 행(클릭→항목 선택)</td>`;
            })();

            const lineNo = getLineNoByRowIndex(rowIdx);
            const curText = state.ctxContent.get(lineNo) ?? "";
            const ctxCell = `
        <td class="ctx-cell" data-cell-kind="CTX" data-line-no="${lineNo}">
          <input
            type="text"
            class="ctx-input"
            data-line-no="${lineNo}"
            placeholder="${escapeHtml(`${lineNo}번 줄 메모`)}"
            value="${escapeHtml(curText)}" />
        </td>
      `;

            return `<tr data-row-index="${rowIdx}">${left}${noteCell}${hourCells}${rightInfo}${ctxCell}</tr>`;
        }).join("");

        table.innerHTML = thead + `<tbody>${rowsHtml}</tbody>`;

        // ✅ 헤더에 updatedAt 1회만 표시
        updateCtxUpdatedAtHeader();
    }

    /***********************
     * MODAL (기존 코드 그대로 유지 가능)
     * - 여기서는 표 개선과 무관하므로 생략해도 되지만,
     *   기존 파일에 붙일 때는 원래 modal 관련 함수 그대로 두면 됨.
     ***********************/
    function openModal(title, bodyHtml, footerHtml){
        $("#modalTitle").textContent = title;
        $("#modalBody").innerHTML = bodyHtml;
        $("#modalFooter").innerHTML = footerHtml ?? "";
        $("#overlay").style.display = "block";
    }
    function closeModal(){ $("#overlay").style.display = "none"; }
    $("#modalClose").addEventListener("click", closeModal);
    $("#overlay").addEventListener("click", (e)=>{ if(e.target === $("#overlay")) closeModal(); });

    // NOTE: 아래 모달 함수들은 기존 코드 그대로 사용하면 됨(생략 없음).
    // ---- 기존 renderTaskDetail, openDefinitionNoteModal, renderBlankRowPicker, renderCreateTaskModal 등 ----
    // 이 샘플에선 길이 때문에 그대로 붙여넣지 않았고,
    // 너는 기존 파일의 모달/태스크 로직을 그대로 유지하면 됨.

    /***********************
     * TABLE INPUT HANDLER (일일메모 저장)
     ***********************/
    $("#chartTable").addEventListener("input", (e)=>{
        const inp = e.target.closest("input.ctx-input");
        if(!inp) return;
        const lineNo = Number(inp.dataset.lineNo);
        if(!Number.isFinite(lineNo)) return;

        state.ctxContent.set(lineNo, inp.value ?? "");
        scheduleSaveDayContextNotes(false);
    });

    $("#chartTable").addEventListener("keydown", (e)=>{
        const inp = e.target.closest("input.ctx-input");
        if(!inp) return;
        if(e.key === "Enter"){
            e.preventDefault();
            const lineNo = Number(inp.dataset.lineNo);
            state.ctxContent.set(lineNo, inp.value ?? "");
            scheduleSaveDayContextNotes(true);
            inp.blur();
        }
    });

    $("#chartTable").addEventListener("focusout", (e)=>{
        const inp = e.target.closest("input.ctx-input");
        if(!inp) return;
        const lineNo = Number(inp.dataset.lineNo);
        if(!Number.isFinite(lineNo)) return;

        state.ctxContent.set(lineNo, inp.value ?? "");
        scheduleSaveDayContextNotes(false);
    });

    /***********************
     * REMAINING: 기존 로딩/새로고침 흐름 (표 개선 반영)
     ***********************/
    function setInputsFromState(){
        $("#jwtInput").value = state.jwtToken ?? "";
        $("#patientIdInput").value = state.patientId ?? "";
        $("#dateInput").value = state.date ?? "";
    }

    async function loadInitial(patientId, date){
        state.patientId = patientId;
        state.date = date;

        try{
            state.staffs = await API.getStaffs();
            state.staffById = new Map((state.staffs ?? []).map(s => [s.id, s]));
        }catch(e){
            state.staffs = [];
            state.staffById = new Map();
            toast(e.message);
        }

        state.patient = await API.getPatient(patientId);

        state.defs = await API.getTaskDefinitions();
        state.defById = new Map(state.defs.map(d => [d.id, d]));
        state.fixedDefs = state.defs.filter(d => !!d.fixed);
        state.notFixedDefs = state.defs.filter(d => !d.fixed);

        state.tasks = await API.getPatientDayTasks(patientId, date);

        try{
            state.definitionNotes = await API.getDefinitionNotes(patientId, date);
        }catch(e){
            state.definitionNotes = [];
        }
        buildNoteMap();

        try{
            const ctx = await API.getDayContextNotes(patientId, date);
            state.dayContextNote = ctx;
            state.ctxContent = buildCtxContentMapFromResponse(ctx);
        }catch(e){
            state.dayContextNote = null;
            state.ctxContent = new Map();
        }

        buildTaskMap();
        buildRows();
        renderPatient();
        renderTable();
    }

    async function reloadAll(showToast=true){
        if(!state.patientId || !state.date) return;
        try{
            if(showToast) toast("새로고침 중...");

            state.patient = await API.getPatient(state.patientId);
            state.defs = await API.getTaskDefinitions();
            state.defById = new Map(state.defs.map(d => [d.id, d]));
            state.fixedDefs = state.defs.filter(d => !!d.fixed);
            state.notFixedDefs = state.defs.filter(d => !d.fixed);
            state.tasks = await API.getPatientDayTasks(state.patientId, state.date);

            try{
                state.definitionNotes = await API.getDefinitionNotes(state.patientId, state.date);
            }catch(e){
                state.definitionNotes = [];
            }
            buildNoteMap();

            try{
                const ctx = await API.getDayContextNotes(state.patientId, state.date);
                state.dayContextNote = ctx;
                state.ctxContent = buildCtxContentMapFromResponse(ctx);
            }catch(e){
                state.dayContextNote = null;
                state.ctxContent = new Map();
            }

            buildTaskMap();
            buildRows();
            renderPatient();
            renderTable();

            if(showToast) toast("새로고침 완료");
        }catch(e){
            toast(e.message);
        }
    }

    async function boot(){
        const { pid, date } = getPathParamsFromUrl();

        const defaultPid = "e2da4625-7158-496f-9f84-9d26b7086ef2";
        const today = new Date();
        const yyyy = today.getFullYear();
        const mm = String(today.getMonth()+1).padStart(2,"0");
        const dd = String(today.getDate()).padStart(2,"0");
        const defaultDate = `${yyyy}-${mm}-${dd}`;

        state.jwtToken = localStorage.getItem("jwtToken") || "";
        state.patientId = pid || defaultPid;
        state.date = date || defaultDate;

        setInputsFromState();

        try{
            await loadInitial(state.patientId, state.date);
            toast("불러오기 완료");
        }catch(e){
            toast(e.message);
        }
    }

    $("#btnLoad").addEventListener("click", async ()=>{
        readJwtFromInputAndPersist();

        const pid = $("#patientIdInput").value.trim();
        const date = $("#dateInput").value;

        if(!pid){ toast("patientId를 입력해줘"); return; }
        if(!date){ toast("date를 선택해줘"); return; }

        const newUrl = `/patients/${pid}/management-charts/${date}`;
        history.pushState({}, "", newUrl);

        try{
            await loadInitial(pid, date);
            toast("불러오기 완료");
        }catch(e){
            toast(e.message);
        }
    });

    $("#btnReload").addEventListener("click", ()=>{
        readJwtFromInputAndPersist();
        reloadAll(true);
    });

    window.closeModal = closeModal;
    boot();
</script>
</body>
</html>
